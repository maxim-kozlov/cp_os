\chapter{Аналитическая часть}
	В данном разделе будут проанализированы различные подходы к трассировке ядра 
	и перехвату функций, а также основные принципы загружаемых модулей ядра.

\section{Существующие решения для трассировки ядра}
	Под трассировкой понимается получение информации о том, 
	что происходит внутри работающей системы. 
	Для этого используются специальные программные инструменты,
	регистрирующие все события в системе. 

	\subsection{Linux Security API}
		Linux Security API -- это специальный интерфейс, позволяющий трассировать ядро линукса начиная с версии 2.6 \cite{lsm}.
		В критических местах кода ядра расположены вызовы security-функций, которые в свою очередь вызывают коллбэки,
		установленные security-модулем.
		Security-модуль может изучать контекст операции и принимать решение о её разрешении или запрете.

		Linux Security API имеет ряд ограничений:
		\begin{enumerate}
			\item security-модули не могут быть загружены динамически, являются частью ядра и требуют его пересборки;
			\item в системе может быть только один security-модуль (с небольшими исключениями).
		\end{enumerate}

		Если по поводу множественности модулей позиция разработчиков ядра неоднозначная, 
		то запрет на динамическую загрузку принципиальный: security-модуль должен быть частью ядра,
		чтобы обеспечивать безопасность постоянно, с момента загрузки. 
		Таким образом, для использования Security API необходимо поставлять собственную сборку ядра,
		а также интегрировать дополнительный модуль с SELinux или AppArmor, 
		которые используются популярными дистрибутивами.

	\subsection{Модификация таблицы системных вызовов}
		В Linux все обработчики системных вызовов хранятся в таблице sys\_call\_table \cite{linux-syscall-reference}.
		Подмена значений в этой таблице приводит к смене поведения всей системы. 
		Таким образом, сохранив старое значения обработчика и подставив в таблицу собственный обработчик, 
		можно перехватить любой системный вызов.

		У этого подхода есть определённые преимущества:
		\begin{enumerate}
			\item Полный контроль над любыми системными вызовами.
				Используя его можно гарантировать перехват действия,
				выполняемого пользовательским процессом.
			\item Минимальные накладные расходы.
				Обновление таблицы системных вызовов происходит один раз при загрузке и выгрузки модуля.
				Помимо полезной нагрузки мониторинга, единственным дополнительным расходом является лишний вызов 
				оригинального обработчика системного вызова.
			\item Минимальные требования к версии ядра.
				Системные таблицы используются в любом ядре Линукса. 
				Однако в новых версиях ядра для передачи аргументов в системные функции
				используются struct pt\_regs, а в старых через стек. 
				Но данную проблему можно решить, используя условную компиляцию и макрос LINUX\_VERSION\_CODE.
		\end{enumerate}
		
		Однако модификация таблицы системных вызовов не лишена недостатков:
		\begin{enumerate}
			\item Техническая сложность реализации.
				Для замены указателей системных функций в таблице необходимо решить следующие задачи:
				\begin{enumerate}
					\item поиск таблицы системных вызовов;
					\item обход защиты от модификации таблицы;
					\item атомарное и безопасное выполнение замены указателей.
				\end{enumerate}
			
			\item Невозможность перехвата некоторых обработчиков. 
				В ядрах до версии 4.16 обработка системных вызовов для архитектуры x86\_64 содержала целый ряд оптимизаций.
				Некоторые из них требовали того, что обработчик системного вызова реализовались на ассемблере. 
				Соответственно, подобные обработчики порой сложно, а иногда и вовсе невозможно заменить на свои, написанные на Си.
				Более того, в разных версиях ядра используются разные оптимизации, что добавляет различные технические сложности.

			\item Перехватываются только системные вызовы.
				Данный подход позволяет подменить таблицу системных вызовов,
				но это ограничивает количество функций, которые можно мониторить.
		\end{enumerate}
	
	\subsection{Kprobes}
		Kprobes -- специализированное API, в первую очередь предназначенного для отладки и трассирования ядра \cite{kprobes}.
		Этот интерфейс позволяет устанавливать пред- и пост- обработчики для любой инструкции в ядре,
		а также обработчики на вход и возврат из функции. 
		Обработчики получают доступ к регистрам и могут их изменять. 
		Таким образом, можно было бы получить как мониторинг, так и возможность влиять на дальнейший ход работы.

		Преимущества, которые даёт использование kprobes для перехвата:
		\begin{enumerate}
			\item Обладает хорошо задокументированным интерфейсом, 
				большинство подводных камней уже найдено,
				их работа по возможности оптимизирована.
			\item Перехват любого места в ядре. 
				Kprobes реализуются с помощью точек останова (инструкции int3), 
				внедряемых в исполнимый код ядра. 
				Это позволяет устанавливать kprobes в буквально любом месте любой функции, если оно известно.
				Аналогично, kretprobes реализуются через подмену адреса возврата на стеке и позволяют перехватить
				возврат из любой функции (за исключением тех, которые управление в принципе не возвращают).
		\end{enumerate}
		
		Недостаткам kprobes являются:
		\begin{enumerate}
			\item Техническая сложность. 
				Kprobes -- это только способ установить точку останова в любом места ядра. 
				Для получения аргументов функции или значений локальных переменных надо знать,
				в каких регистрах или где на стеке они лежат, и самостоятельно их оттуда извлекать.
				Для блокировки вызова функции необходимо вручную модифицировать состояние процесса так,
				чтобы процессор подумал, что он уже вернул управление из функции.

			\item Jprobes объявлены устаревшими. 
				Jprobes -- это надстройка над kprobes, позволяющая удобно перехватывать вызовы функций.
				Она самостоятельно извлечёт аргументы функции из регистров или стека и вызовет ваш обработчик,
				который должен иметь ту же сигнатуру, что и перехватываемая функция. 
				Проблема заключается в том, что jprobes объявлены устаревшими и вырезаны из современных ядер.

			\item Нетривиальные накладные расходы. 
				Расстановка точек останова дорогая, но она выполняется единоразово. 
				Точки останова не влияют на остальные функции, однако их обработка относительно недешёвая.
				Для архитектуры x86\_64 реализована jump-оптимизация, существенно уменьшающая стоимость kprobes,
				но она всё ещё остаётся больше, чем, например, при модификации таблицы системных вызовов.

			\item Ограничения kretprobes. 
				Kretprobes реализуются через подмену адреса возврата на стеке. 
				Соответственно, им необходимо где-то хранить оригинальный адрес,
				чтобы вернуться туда после обработки kretprobe. 
				Адреса хранятся в буфере фиксированного размера. 
				В случае его переполнения, когда в системе выполняется слишком много одновременных вызовов перехваченной функции, 
				kretprobes будет пропускать срабатывания.

			\item Отключенное вытеснение. 
				Kprobes основывается на прерываниях и может менять значения в регистрах процессора,
				следовательно для синхронизации все обработчики выполняются с отключенным вытеснением (preemption).
				Это накладывает определённые ограничения на обработчики: 
				в них нельзя ждать -- выделять много памяти, заниматься вводом-выводом, 
				спать в таймерах и семафорах, и прочее.
		\end{enumerate}

	\subsection{Kernel tracepoints}
		Kernel tracepoints -- это фреймворк для трассировки ядра, 
		сделанный через статическое инструментирование кода \cite{linux-kernel-tracepoints}.
		Точка трассировки, помещенная в код, обеспечивает ловушку для вызова функции (зонда),
		которую можно предоставить во время выполнения. 
		Точка трассировки может быть "включена" (к ней подключен зонд) или "выключена" (зонд не подключен).
		Когда точка трассировки выключена, она не оказывает никакого эффекта, 
		за исключением проверки условия для перехода и добавлением нескольких байтов для вызова функции 
		в конце инструментированной функции и добавление данных структуру в отдельный раздел.
		Когда точка трассировки включена, предоставляемая функция вызывается каждый раз при выполнении точки трассировки
		в контексте выполнения вызывающей стороны.

		Точки трассировки можно разместить в важных местах кода. 
		Это легкие обработчики, которые могут передавать произвольное количество параметров,
		прототипы которых описаны в объявлении точки трассировки, помещенном в файл заголовка.
		В основном они используются для отслеживания и учета производительности.
		
		Преимуществами данного способа являются:
		\begin{enumerate}
			\item Малые накладные расходы на внедрение в загружаемые модули ядра.
				Необходимо только вызвать функцию трассировки в необходимом месте.

			\item Маленькие затраты по памяти и процессорному времени.
		\end{enumerate}

		К недостаткам можно отнести:
		\begin{enumerate}
			\item Имена точек трассировки являются глобальными для ядра. 
			Они считаются одинаковыми независимо от того, находятся ли они в ядре или в загружаемых модулях.
			\item Для добавления точек остановки в ядровые функции необходимо перекомпилировать ядро,
			если для данных функций не данные точки не определенны.
			\item Относительно плохо задокументированное API.
		\end{enumerate}
		
	\subsection{Сплайсинг}
		Сплайсинг - способ перехвата функций, заключающийся в замене инструкций в начале функции
		на безусловный переход, ведущий в обработчик \cite{splice-hooking}. 
		Оригинальные инструкции переносятся в другое место и исполняются перед переходом обратно в перехваченную функцию.
		С помощью двух переходов вшивается (splice in) дополнительный код в функцию, поэтому такой подход называется сплайсингом.
		Именно таким образом и реализуется jump-оптимизация для kprobes. 
		Используя сплайсинг можно добиться тех же результатов, но без дополнительных расходов на kprobes и с полным контролем ситуации.
		
		Преимуществами сплайсинга являются:
		\begin{enumerate}
			\item Минимальные требования к ядру. 
				Сплайсинг не требует каких-либо особенных опций в ядре и работает в начале любой функции, 
				необходимо лишь знать её адрес.
			\item Минимальные накладные расходы. 
				Два безусловных перехода, которые надо выполнить перехваченному коду, чтобы передать управление обработчику и обратно.
				Подобные переходы отлично предсказываются процессором и являются очень дешёвыми.
			\item Менее заметны для детекторов вредоносных программ.
			\item Позволяет подключать все доступные символы в ядре.
		\end{enumerate}
		
		К недостаткам данного подхода можно отнести:
		\begin{enumerate}
			\item Требует надёжный метод дизассемблерования кода ядра.
			\item Зависит от архитектуры, поскольку каждая архитектура имеет свои собственные инструкции перехода.
			\item Большая техническая сложность реализации. Ниже приведён краткий и неполный список задач, которые необходимо решить:
			\begin{enumerate}
				\item синхронизация установки и снятия перехвата;
				\item обход защиты от модификации областей памяти с исходным кодом ядра;
				\item инвалидация кешей процессора после замены инструкций;
				\item дизассемблирование заменяемых инструкций, чтобы скопировать их целыми;
				\item проверка на отсутствие переходов внутрь заменяемого куска;
				\item проверка на возможность переместить заменяемый кусок в другое место;
			\end{enumerate}
		\end{enumerate}

	\subsection{Ftrace}
		Ftrace -- это фреймворк для трассирования ядра на уровне функций \cite{ftrace}.
		Его можно использовать для отладки или анализа задержек и проблем с производительностью, 
		возникающих за пределами пользовательского пространства.

		Хотя ftrace обычно считается трассировщиком функций, 
		на самом деле это структура из нескольких различных утилит трассировки. 
		Имеется трассировка задержки для изучения того, 
		что происходит между отключенными и включенными прерываниями, 
		а также для вытеснения и с момента пробуждения задачи до фактического запланированного выполнения задачи.
		
		Реализуется ftrace на основе ключей компилятора -pg и -mfentry, 
		которые вставляют в начало каждой функции вызов специальной трассировочной функции 
		mcount() или \_\_fentry\_\_(). 
		Обычно, в пользовательских программах эта возможность компилятора используется профилировщиками,
		чтобы отслеживать вызовы всех функций. Ядро же использует эти функции для реализации фреймворка ftrace.

		Вызов ftrace не является дешёвой операцией,
		поэтому для популярных архитектур доступна оптимизация: динамический ftrace. 
		Суть заключается в том, что ядро знает расположение всех вызовов mcount() или \_\_fentry\_\_() 
		и на ранних этапах загрузки заменяет их машинный код на nop -- специальную ничего не делающую инструкцию. 
		При включении трассирования в нужные функции вызовы ftrace добавляются обратно. 
		Таким образом, если ftrace не используется, то его влияние на систему минимально.

		Ниже описаны преимущества данного подхода:
		\begin{enumerate}
			\item Использование готовых интерфейсов в ядре существенно упрощает код. 
				Вся установка перехвата требует пары вызовов функций и заполнение двух полей в структуре.
			\item Перехват любой функции по имени. 
				Для указания интересующей нас функции достаточно написать её имя в обычной строке. 
				Не требуются большой разбор внутренних структур данных ядра, сканирование памяти, или дизассемблерования кода ядра.
				Можно перехватить любую функцию (даже не экспортируемую для модулей), зная лишь её имя.
			\item Перехват совместим с трассировкой.
				Данный способ не конфликтует с ftrace,
				так что с ядра можно снимать полезные показатели производительности. 
				Однако использование kprobes или сплайсинга может помешать механизмам ftrace.
			\item Средние накладные расходы. 
				Накладные расходы на ftrace меньше, чем у kprobes (так как ftrace не использует точки останова),
				но они выше, чем у сплайсинга, сделанного вручную. 
				В действительности динамический ftrace является сплайсингом, только дополнительно выполняющий код ftrace и другие коллбеки.
		\end{enumerate}

		К недостаткам данного подхода можно отнести:
		\begin{enumerate}
			\item Требования к конфигурации ядра. 
			Для успешного выполнения перехвата функций с помощью ftrace ядро должно предоставлять целый ряд возможностей:
			\begin{enumerate}
				\item список символов kallsyms для поиска функций по имени;
				\item фреймворк ftrace для выполнения трассировки;
				\item различные опции ftrace важные для перехвата.
			\end{enumerate}
			\item Оборачиваются функции целиком. 
				Как и сплайсинг, данный подход полностью оборачивает вызовы функций.
				Однако, если сплайсинг технически возможно выполнить в любом месте функции,
				то ftrace срабатывает исключительно при входе. 
				Естественно, обычно это не вызывает сложностей и даже наоборот удобно,
				но подобное ограничение иногда может быть недостатком.
		\end{enumerate}

	\subsection{Вывод}
		В таблице \ref{table:compare:hooking} приведено сравнение рассмотренных методов.
		\begin{table}[]
			\caption{Сравнение существующих методов трассировки ядра.}
			\centering
			\begin{tabular}{|c|c|c|c|c|c|c|}
				\hline
				Критерий                                                              & \begin{tabular}[c]{@{}c@{}}Linux \\ Security\end{tabular}      & \begin{tabular}[c]{@{}c@{}}Модификация\\ syscall table\end{tabular} & Kprobes                                                        & \begin{tabular}[c]{@{}c@{}}Kernel\\ tracepoints\end{tabular}   & Сплайсинг                                                      & Ftrace                                                                   \\ \hline
				\begin{tabular}[c]{@{}c@{}}Накладные\\ расходы\end{tabular}           & Средние                                                        & \begin{tabular}[c]{@{}c@{}}Мини-\\ мальные\end{tabular}             & Большие                                                        & Малые                                                          & \begin{tabular}[c]{@{}c@{}}Мини-\\ мальные\end{tabular}        & Средние                                                                  \\ \hline
				\begin{tabular}[c]{@{}c@{}}Сложность\\ реализации\end{tabular}        & Средняя                                                        & Средняя                                                             & Большая                                                        & Средняя                                                        & \begin{tabular}[c]{@{}c@{}}Очень\\ большая\end{tabular}        & Малая                                                                    \\ \hline
				\begin{tabular}[c]{@{}c@{}}Требуется\\ компиляция\\ ядра\end{tabular} & Да                                                             & Нет                                                                 & Иногда                                                         & Иногда                                                         & Нет                                                            & Нет                                                                      \\ \hline
				\begin{tabular}[c]{@{}c@{}}Возможности\\ мониторинга\end{tabular}     & \begin{tabular}[c]{@{}c@{}}Ряд\\ функции\end{tabular}          & \begin{tabular}[c]{@{}c@{}}Системные\\ функции\end{tabular}         & \begin{tabular}[c]{@{}c@{}}Любое\\ место\\ в ядре\end{tabular} & \begin{tabular}[c]{@{}c@{}}Любое\\ место\\ в ядре\end{tabular} & \begin{tabular}[c]{@{}c@{}}Любое\\ место\\ в ядре\end{tabular} & \begin{tabular}[c]{@{}c@{}}Большинство\\ функции\\ по имени\end{tabular} \\ \hline
				\begin{tabular}[c]{@{}c@{}}Докумен-\\ тация\end{tabular}              & Средняя                                                        & Средняя                                                             & Средняя                                                        & Малая                                                          & Малая                                                          & Большая                                                                  \\ \hline
				\begin{tabular}[c]{@{}c@{}}Требования\\ к ядру\end{tabular}           & \begin{tabular}[c]{@{}c@{}}Версия \\ старше\\ 2.6\end{tabular} & Нет                                                                 & \begin{tabular}[c]{@{}c@{}}Версия \\ младше\\ 2.5\end{tabular} & -                                                              & \begin{tabular}[c]{@{}c@{}}Версия \\ младше\\ 2.5\end{tabular} & \begin{tabular}[c]{@{}c@{}}Наличие\\ ftrace\end{tabular}                 \\ \hline
				\end{tabular}
			\label{table:compare:hooking}
		\end{table}

		В ходе анализа приведенных подходов к перехвату функций,
		были выбраны метод модификации таблицы системных вызовов и фреймворк ftrace, 
		так как первый позволит перехватить вызов системных функции sys\_read, sys\_write, sys\_open и sys\_close 
		без больших накладных расходов.
		Второй же метод будет перехватывать функции bdev\_read\_page, bdev\_write\_page и random\_read, 
		т.к. они не являются системными.
		Основными критериями выбора были необходимость перекомпилировать ядро,
		требования к ядру, а также сложность программной реализации.

\section{Загружаемые модули ядра Linux}
	Linux является динамическим ядром, 
	поддерживающим добавление и удаление программных компонентов на лету \cite{anatomy-linux-kernel}.
	Это означает, есть возможность добавить функциональность в ядро (и убрать её), когда система запущена и работает.
	Они называются динамически загружаемыми модулями ядра.
	Ядро Linux предлагает поддержку довольно большого числа типов (или классов) модулей.
	Каждый модуль является подготовленным объектным кодом (не слинкованным для самостоятельной работы),
	который может быть динамически подключен в работающее ядро, а позднее может быть выгружен из ядра.
	Каждый модуль ядра регистрирует себя для того, чтобы обслуживать в будущем запросы,
	и его функция инициализации немедленно прекращается. 
	Иными словами, задача функции инициализации модуля заключается в подготовке функций модуля для последующего вызова.
	Функция выхода модуля вызывается только непосредственно перед выгрузкой модуля. 
	Функция выхода модуля должна тщательно отменить все изменения, сделанные функцией инициализации, 
	или функции модуля сохранятся до перезагрузки системы. 
	Возможность выгрузить модуль помогает сократить время разработки; 
	можно тестировать последовательные версии новых драйверов, 
	не прибегая каждый раз к длительному циклу выключения/перезагрузки. 
	Модуль связан только с ядром и может вызывать только те функции, 
	которые экспортированы ядром, нет библиотек для установления связи. 
	Например, функция printk, является версией printf, 
	определённой в ядре и экспортированной для модулей.
	
\section{Пространство пользователя и пространство ядра}
	Систему памяти в Linux можно разделить на две различные области: пространства ядра и пользовательского пространства.
	Пространство ядра -- адресное пространство в абсолютных адресах,
	где выполняется ядро операционной системы и предоставляет свои услуги \cite{linux-kernel-space}.
	Пользовательское пространство (user space) -- адресное пространство виртуальной памяти операционной системы,
	в которой выполняются процессы пользователя \cite{linux-user-space}.
	
	Доступ к пространству ядра для пользовательских процессов возможен только с помощью системных вызовов.
	Системные вызовы -- это запросы в Unix-подобной операционной системе активного процесса для службы,
	выполняемой ядром, такой как ввод/вывод (I/O) или создание процесса и т.д.

\section{Вывод}
	В данном разделе были проанализированы подходы к трассировке ядра и перехвату функций и 
	выбраны наиболее оптимальные методы для реализации поставленных задач -- модификации таблицы
	системных вызовов и фреймворк ftrace, 
	а также рассмотрены основные принципы загружаемых модулей ядра и понятия пространства ядра и пространства пользователя.
	
\pagebreak