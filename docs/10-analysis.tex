\chapter{Аналитический раздел}
	\section{Постановка задачи}
		В соответствии с заданием на курсовую работу
		необходимо разработать загружаемый модуль ядра,
	 	позволяющий перехватывать системные вызовы:
		bdev\_read\_page,
		bdev\_write\_page,
		sys\_read,
		sys\_write,
		sys\_open,
		sys\_close,
		random\_read и выводить в системный журнал информацию о 
		идентификаторе вызывающего процесса, 
		передаваемых параметрах и возвращаемого значения.

		Для достижения поставленной цели требуется решить следующие задачи:
		\begin{enumerate}
			\item проанализировать перехватываемые функции;
			\item проанализировать существующие способы перехвата функций;
			\item реализовать загружаемый модуль ядра;
			\item исследовать поведение перехваченных функций.
		\end{enumerate}
	
	\section{Анализ перехватываемых системных вызовов}
		Перехватываемые системные функции позволяют 
		отслеживать работу системы относительно 
		основных операций по работе с файловыми системами,
		а также связанных с символьными и блочными устройствами.

		Сигнатуры данных функций зависят от версии ядра Linux, 
		поэтому будет реализована поддержка только версии ядра 5.0.
		Все дальнейшие структуры и функции ядра приведены для данной версии ядра, 
		если явно не указана иная.
		
	\subsection*{Анализ системного вызова bdev\_read\_page}
		Функция bdev\_read\_page имеет следующую сигнатуру \cite{linux-bdev_read_page}:\\
		\lstinline{int bdev_read_page(struct block_device *bdev, sector_t sector, struct page *page)},

		где \lstinline{struct block_device *bdev} -- блочное устройство с которого считывается информация,

		\lstinline{sector_t sector} -- смещение на устройстве для чтения страницы,
		
		\lstinline{struct page *page} -- страница для записи считанных данных.

		Данная функция начинает операцию чтения страницы с блочного устройства, 
		блокируя страницу на время выполнения.
		Ошибки возвращаемые этой функцией (отрицательный \lstinline{errno}), обычно <<мягкие>>, 
		т.е. существуют альтернативные способы чтения данных с устройства и
		не требуется распространять ошибку вверх по стеку вызовов.

	 \subsection*{Анализ системного вызова bdev\_write\_page}
		Функция bdev\_write\_page имеет следующую сигнатуру \cite{linux-bdev_write_page}:\\
		\lstinline{int bdev_write_page(struct block_device *bdev, sector_t sector, struct page *page, struct writeback_control *wbc)},
		
		где \lstinline{struct block_device *bdev} -- блочное устройство для записи страницы,

		\lstinline{sector_t sector} -- смещение на устройстве на которое будет записана страница,

		\lstinline{struct page *page} -- страница с записываемыми данными,

		\lstinline{struct writeback_control * wb} -- управляющая структура, которая сообщает коду обратной записи, как производиться запись.
		
		Функция начинает операцию записи страницы на блочное устройство, блокируя страницу на время выполнения.
		Обработка ошибок, возвращаемых данной функцией аналогична bdev\_read\_page.

	\subsection*{Анализ системного вызова sys\_open}
		Системный вызов sys\_open открывает файл по переданному символьному имени filename.
	    Данная функция имеет следующую сигнатуру \cite{linux-sys_open}: \\
		\lstinline{SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)}.

	   Возвращаемое значение open() -- это дескриптор файла, неотрицательное целое число, 
	   которое является индексом записи в таблица дескрипторов открытых файлов.
	   Используя различные флаги можно изменить поведение open().
	   Например, если файл не был найден и указан флаг O\_CREAT, 
	   то будет создан новый файл с указанным именем.

	 \subsection*{Анализ системного вызова sys\_read}
	 	Системный вызов sys\_read считывает из файла, 
		на который ссылается файловый дескриптор fd,
		count байт и записывает их в buf -- буфер из пространства пользователя.
		Данная функция имеет следующую сигнатуру \cite{linux-sys_read}: \\
		\lstinline{SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)}.

		Операция чтения начинается со смещения указанного в struct file, 
		после чего смещение файла увеличивается на число прочитанных байтов. 
		Если смещение файла находится в конце или больше конца файла,
		байты не читаются, а read возвращает ноль.

	 \subsection*{Анализ системного вызова sys\_write}
		Системный вызов sys\_write записывает в файл, 
		на который ссылается файловый дескриптор fd,
		count байтов из буфера buf -- буфера пространства пользователя.
		Данная функция имеет следующую сигнатуру \cite{linux-sys_write}: \\
	 	\lstinline{SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)}.

		Операция записи происходит в файл с указанного смещение,
		а смещение файла увеличивается на количество записанных байтов.
		Если файл был открыт с флагом O\_APPEND, 
		смещение файла сначала устанавливается на конец файла перед записью.
       	Регулировка смещения файла и операция записи выполняется как атомарный шаг.

	 \subsection*{Анализ системного вызова sys\_close}
	 	Системный вызов sys\_close закрывает файл, на который ссылается файловый дескриптор fd, освобождая ресурсы.
		Данная функция имеет следующую сигнатуру \cite{linux-sys_close}: \\
	 	\lstinline{SYSCALL_DEFINE1(close, unsigned int, fd)}.

	 \subsection*{Анализ системного вызова random\_read}
	 	Функция random\_read позволяет считывать массив байт из символьного 
		устройства /dev/random и имеет следующую сигнатуру \cite{linux-random_read}: 
	 \lstinline{static ssize_t random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)}.
		
	 	Символьное устройство /dev/random генерирует случайные последовательности байт, 
		используя в качестве источника энтропии CSPRNG (криптографически безопасного генератора псевдослучайных чисел).
		Существует похожая функция \lstinline{static ssize_t urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)},
		считывающая данные из символьного устройства 
		/dev/urandom которое отличающается от /dev/random лишь тем, что
		когда энтропия останавливается, он продолжает генерировать последовательности байт. 

\section{Анализ способов перехвата системных вызовов}
	% Под трассировкой понимается получение информации о том, 
	% что происходит внутри работающей системы. 
	% Для этого используются специальные программные инструменты,
	% регистрирующие все события в системе. 
	% Рассмотрим существующие методы перехвата системных вызовов, 

	\subsection*{Linux Security API}
		Linux Security API -- это специальный интерфейс, позволяющий трассировать ядро линукса начиная с версии 2.6 \cite{lsm}.
		В критических местах кода ядра расположены вызовы security-функций, которые в свою очередь вызывают коллбэки,
		установленные security-модулем.
		Security-модуль может изучать контекст операции и принимать решение о её разрешении или запрете.

		Linux Security API имеет ряд ограничений:
		\begin{enumerate}
			\item security-модули не могут быть загружены динамически, являются частью ядра и требуют его пересборки;
			\item в системе может быть только один security-модуль (с небольшими исключениями).
		\end{enumerate}

		Если по поводу множественности модулей позиция разработчиков ядра неоднозначная, 
		то запрет на динамическую загрузку принципиальный: security-модуль должен быть частью ядра,
		чтобы обеспечивать безопасность постоянно, с момента загрузки. 
		Таким образом, для использования Security API необходимо поставлять собственную сборку ядра,
		а также интегрировать дополнительный модуль с SELinux или AppArmor, 
		которые используются популярными дистрибутивами.

	\subsection*{Модификация таблицы системных вызовов}
		В Linux все обработчики системных вызовов хранятся в таблице sys\_call\_table \cite{linux-syscall-reference}.
		Подмена значений в этой таблице приводит к смене поведения всей системы. 
		Таким образом, сохранив старое значения обработчика и подставив в таблицу собственный обработчик, 
		можно перехватить любой системный вызов.

		У этого подхода есть определённые преимущества:
		\begin{enumerate}
			\item Полный контроль над любыми системными вызовами.
				Используя его можно гарантировать перехват действия,
				выполняемого пользовательским процессом.
			\item Минимальные накладные расходы.
				Обновление таблицы системных вызовов происходит один раз при загрузке и выгрузки модуля.
				Помимо полезной нагрузки мониторинга, единственным дополнительным расходом является лишний вызов 
				оригинального обработчика системного вызова.
			\item Минимальные требования к версии ядра.
				Системные таблицы используются в любом ядре Линукса. 
				Однако в новых версиях ядра для передачи аргументов в системные функции
				используются struct pt\_regs. 
				Но данную проблему можно решить, используя условную компиляцию и макрос LINUX\_VERSION\_CODE.
		\end{enumerate}
		
		Однако модификация таблицы системных вызовов не лишена недостатков:
		\begin{enumerate}
			\item Техническая сложность реализации.
				Для замены указателей системных функций в таблице необходимо решить следующие задачи:
				\begin{enumerate}
					\item поиск таблицы системных вызовов;
					\item обход защиты от модификации таблицы;
					\item атомарное и безопасное выполнение замены указателей.
				\end{enumerate}
			
			\item Невозможность перехвата некоторых обработчиков. 
				В ядрах до версии 4.16 обработка системных вызовов для архитектуры x86\_64 содержала целый ряд оптимизаций.
				Некоторые из них требовали того, что обработчик системного вызова реализовались на ассемблере. 
				Соответственно, подобные обработчики порой сложно, а иногда и вовсе невозможно заменить на свои, написанные на Си \cite{habr-ftrace}.
				Более того, в разных версиях ядра используются разные оптимизации, что добавляет различные технические сложности.

			\item Перехватываются только системные вызовы.
				Данный подход позволяет подменить таблицу системных вызовов,
				но это ограничивает количество функций, которые можно мониторить.
		\end{enumerate}
	
	\subsection*{Kprobes}
		Kprobes -- специализированное API, в первую очередь предназначенного для отладки и трассирования ядра \cite{kprobes}.
		Этот интерфейс позволяет устанавливать пред- и пост- обработчики для любой инструкции в ядре,
		а также обработчики на вход и возврат из функции. 
		Обработчики получают доступ к регистрам и могут их изменять. 
		Таким образом, можно было бы получить как мониторинг, так и возможность влиять на дальнейший ход работы.

		Преимущества, которые даёт использование kprobes для перехвата:
		\begin{enumerate}
			\item Обладает хорошо задокументированным интерфейсом, 
				большинство подводных камней уже найдено,
				их работа по возможности оптимизирована.
			\item Перехват любого места в ядре. 
				Kprobes реализуются с помощью точек останова (инструкции int3), 
				внедряемых в исполнимый код ядра. 
				Это позволяет устанавливать kprobes в буквально любом месте любой функции, если оно известно.
				Аналогично, kretprobes реализуются через подмену адреса возврата на стеке и позволяют перехватить
				возврат из любой функции (за исключением тех, которые управление в принципе не возвращают).
		\end{enumerate}
		
		Недостаткам kprobes являются:
		\begin{enumerate}
			\item Техническая сложность. 
				Kprobes -- это только способ установить точку останова в любом места ядра. 
				Для получения аргументов функции или значений локальных переменных надо знать,
				в каких регистрах или где на стеке они лежат, и самостоятельно их оттуда извлекать.
				Для блокировки вызова функции необходимо вручную модифицировать состояние процесса так,
				чтобы процессор подумал, что он уже вернул управление из функции.

			\item Jprobes объявлены устаревшими. 
				Jprobes -- это надстройка над kprobes, позволяющая удобно перехватывать вызовы функций.
				Она самостоятельно извлечёт аргументы функции из регистров или стека и вызовет ваш обработчик,
				который должен иметь ту же сигнатуру, что и перехватываемая функция. 
				Проблема заключается в том, что jprobes объявлены устаревшими и вырезаны из современных ядер
				(начиная с версия 3.19).

			\item Нетривиальные накладные расходы. 
				Расстановка точек останова дорогая, но она выполняется единоразово. 
				Точки останова не влияют на остальные функции, однако их обработка относительно недешёвая.
				Для архитектуры x86\_64 реализована jump-оптимизация, существенно уменьшающая стоимость kprobes,
				но она всё ещё остаётся больше, чем, например, при модификации таблицы системных вызовов.

			\item Ограничения kretprobes. 
				Kretprobes реализуются через подмену адреса возврата на стеке. 
				Соответственно, им необходимо где-то хранить оригинальный адрес,
				чтобы вернуться туда после обработки kretprobe. 
				Адреса хранятся в буфере фиксированного размера. 
				В случае его переполнения, когда в системе выполняется слишком много одновременных вызовов перехваченной функции, 
				kretprobes будет пропускать срабатывания.

			\item Отключенное вытеснение. 
				Kprobes основывается на прерываниях и может менять значения в регистрах процессора,
				следовательно для синхронизации все обработчики выполняются с отключенным вытеснением (preemption).
				Это накладывает определённые ограничения на обработчики: 
				в них нельзя ждать -- выделять много памяти, заниматься вводом-выводом, 
				спать в таймерах и семафорах, и прочее.
		\end{enumerate}

	\subsection*{Kernel tracepoints}
		Kernel tracepoints -- это фреймворк для трассировки ядра, 
		сделанный через статическое инструментирование кода \cite{linux-kernel-tracepoints}.
		Точка трассировки, помещенная в код, обеспечивает ловушку для вызова функции (зонда),
		которую можно предоставить во время выполнения. 
		Точка трассировки может быть "включена" (к ней подключен зонд) или "выключена" (зонд не подключен).
		Когда точка трассировки выключена, она не оказывает никакого эффекта, 
		за исключением проверки условия для перехода и добавлением нескольких байтов для вызова функции 
		в конце инструментированной функции и добавление данных структуру в отдельный раздел.
		Когда точка трассировки включена, предоставляемая функция вызывается каждый раз при выполнении точки трассировки
		в контексте выполнения вызывающей стороны.

		Точки трассировки можно раместить в важных местах кода. 
		Это легкие обработчики, которые могут передавать произвольное количество параметров,
		прототипы которых описаны в объявлении точки трассировки, помещенном в файл заголовка.
		В основном они используются для отслеживания и учета производительности.
		
		Преимуществами данного способа являются:
		\begin{enumerate}
			\item Малые накладные расходы на внедрение в загружаемые модули ядра.
				Необходимо только вызвать функцию трассировки в необходимом месте.

			\item Маленькие затраты по памяти и процессорному времени.
		\end{enumerate}

		Недостатками данного подхода являются:
		\begin{enumerate}
			\item Имена точек трассировки являются глобальными для ядра. 
			Они считаются одинаковыми независимо от того, находятся ли они в ядре или в загружаемых модулях.
			\item Для добавления точек остановки в ядровые функции необходимо перекомпилировать ядро,
			если для данных функций не данные точки не определенны.
			\item Относительно плохо задокументированное API.
		\end{enumerate}
		
	\subsection*{Сплайсинг}
		Сплайсинг -- способ перехвата функций, заключающийся в замене инструкций в начале функции
		на безусловный переход, ведущий в обработчик \cite{splice-hooking}. 
		Оригинальные инструкции переносятся в другое место и исполняются перед переходом обратно в перехваченную функцию.
		С помощью двух переходов вшивается (splice in) дополнительный код в функцию, поэтому такой подход называется сплайсингом.
		Именно таким образом и реализуется jump-оптимизация для kprobes. 
		Используя сплайсинг можно добиться тех же результатов, но без дополнительных расходов на kprobes и с полным контролем ситуации.
		
		Преимуществами сплайсинга являются:
		\begin{enumerate}
			\item Минимальные требования к ядру. 
				Сплайсинг не требует каких-либо особенных опций в ядре и работает в начале любой функции, 
				необходимо лишь знать её адрес.
			\item Минимальные накладные расходы. 
				Два безусловных перехода, которые надо выполнить перехваченному коду, чтобы передать управление обработчику и обратно.
				Подобные переходы отлично предсказываются процессором и являются очень дешёвыми.
			\item Менее заметны для детекторов вредоносных программ.
			\item Позволяет подключать все доступные символы в ядре.
		\end{enumerate}
		
		Недостатками данного подхода являются:
		\begin{enumerate}
			\item Требования к надёжному метод дизассемблерования кода ядра.
			\item Зависимость от архитектуры, поскольку каждая архитектура имеет свои собственные инструкции перехода.
			\item Большая техническая сложность реализации. Ниже приведён краткий и неполный список задач, которые необходимо решить:
			\begin{enumerate}
				\item синхронизация установки и снятия перехвата;
				\item обход защиты от модификации областей памяти с исходным кодом ядра;
				\item инвалидация кешей процессора после замены инструкций;
				\item дизассемблирование заменяемых инструкций, чтобы скопировать их целыми;
				\item проверка на отсутствие переходов внутрь заменяемого куска;
				\item проверка на возможность переместить заменяемый кусок в другое место;
			\end{enumerate}
		\end{enumerate}

	\subsection*{Ftrace}
		Ftrace -- это фреймворк для трассирования ядра на уровне функций \cite{ftrace}.
		Его можно использовать для отладки или анализа задержек и проблем с производительностью, 
		возникающих за пределами пользовательского пространства.

		Хотя ftrace обычно считается трассировщиком функций, 
		на самом деле это структура из нескольких различных утилит трассировки. 
		Имеется трассировка задержки для изучения того, 
		что происходит между отключенными и включенными прерываниями, 
		а также для вытеснения и с момента пробуждения задачи до фактического запланированного выполнения задачи.
		
		Реализуется ftrace на основе ключей компилятора -pg и -mfentry, 
		которые вставляют в начало каждой функции вызов специальной трассировочной функции 
		mcount() или \_\_fentry\_\_(). 
		Обычно, в пользовательских программах эта возможность компилятора используется профилировщиками,
		чтобы отслеживать вызовы всех функций. Ядро же использует эти функции для реализации фреймворка ftrace.

		Вызов ftrace не является дешёвой операцией,
		поэтому для популярных архитектур доступна оптимизация: динамический ftrace. 
		Суть заключается в том, что ядро знает расположение всех вызовов mcount() или \_\_fentry\_\_() 
		и на ранних этапах загрузки заменяет их машинный код на nop -- специальную ничего не делающую инструкцию. 
		При включении трассирования в нужные функции вызовы ftrace добавляются обратно. 
		Таким образом, если ftrace не используется, то его влияние на систему минимально.

		Достоинствами ftrace являются:
		\begin{enumerate}
			\item Использование готовых интерфейсов в ядре существенно упрощает код. 
				Вся установка перехвата требует пары вызовов функций и заполнение двух полей в структуре.
			\item Перехват любой функции по имени. 
				Для указания интересующей нас функции достаточно написать её имя в обычной строке. 
				Не требуются большой разбор внутренних структур данных ядра, сканирование памяти, или дизассемблерования кода ядра.
				Можно перехватить любую функцию (даже не экспортируемую для модулей), зная лишь её имя.
			\item Перехват совместим с трассировкой.
				Данный способ не конфликтует с ftrace,
				так что с ядра можно снимать полезные показатели производительности. 
				Однако использование kprobes или сплайсинга может помешать механизмам ftrace.
			\item Средние накладные расходы. 
				Накладные расходы на ftrace меньше, чем у kprobes (так как ftrace не использует точки останова),
				но они выше, чем у сплайсинга, сделанного вручную. 
				В действительности динамический ftrace является сплайсингом, только дополнительно выполняющий код ftrace и другие коллбеки.
		\end{enumerate}

		Недостатками данного подхода являются:
		\begin{enumerate}
			\item Требования к конфигурации ядра. 
			Для успешного выполнения перехвата функций с помощью ftrace ядро должно предоставлять целый ряд возможностей:
			\begin{enumerate}
				\item список символов kallsyms для поиска функций по имени;
				\item фреймворк ftrace для выполнения трассировки;
				\item различные опции ftrace важные для перехвата.
			\end{enumerate}
			\item Оборачивание функции целиком. 
				Как и сплайсинг, данный подход полностью оборачивает вызовы функций.
				Однако, если сплайсинг технически возможно выполнить в любом месте функции,
				то ftrace срабатывает исключительно при входе. 
				Естественно, обычно это не вызывает сложностей и даже наоборот удобно,
				но подобное ограничение иногда может быть недостатком.
		\end{enumerate}

\section{Сравнительный анализ методов трассировки ядра}
	В таблице \ref{table:compare:hooking} приведено сравнение рассмотренных методов перехвата системных вызовов.
	\begin{table}[h!]
		\caption{Сравнение существующих методов трассировки ядра.}
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline
			Критерий                                                              & \begin{tabular}[c]{@{}c@{}}Linux \\ Security\end{tabular}      & \begin{tabular}[c]{@{}c@{}}Модификация\\ syscall table\end{tabular} & Kprobes                                                        & \begin{tabular}[c]{@{}c@{}}Kernel\\ tracepoints\end{tabular}   & Сплайсинг                                                      & Ftrace                                                                   \\ \hline
			\begin{tabular}[c]{@{}c@{}}Накладные\\ расходы\end{tabular}           & Средние                                                        & \begin{tabular}[c]{@{}c@{}}Мини-\\ мальные\end{tabular}             & Большие                                                        & Малые                                                          & \begin{tabular}[c]{@{}c@{}}Мини-\\ мальные\end{tabular}        & Средние                                                                  \\ \hline
			\begin{tabular}[c]{@{}c@{}}Сложность\\ реализации\end{tabular}        & Средняя                                                        & Средняя                                                             & Большая                                                        & Средняя                                                        & \begin{tabular}[c]{@{}c@{}}Очень\\ большая\end{tabular}        & Малая                                                                    \\ \hline
			\begin{tabular}[c]{@{}c@{}}Требуется\\ компиляция\\ ядра\end{tabular} & Да                                                             & Нет                                                                 & Иногда                                                         & Иногда                                                         & Нет                                                            & Нет                                                                      \\ \hline
			\begin{tabular}[c]{@{}c@{}}Возможности\\ мониторинга\end{tabular}     & \begin{tabular}[c]{@{}c@{}}Ряд\\ функции\end{tabular}          & \begin{tabular}[c]{@{}c@{}}Системные\\ функции\end{tabular}         & \begin{tabular}[c]{@{}c@{}}Любое\\ место\\ в ядре\end{tabular} & \begin{tabular}[c]{@{}c@{}}Любое\\ место\\ в ядре\end{tabular} & \begin{tabular}[c]{@{}c@{}}Любое\\ место\\ в ядре\end{tabular} & \begin{tabular}[c]{@{}c@{}}Большинство\\ функции\\ по имени\end{tabular} \\ \hline
			\begin{tabular}[c]{@{}c@{}}Докумен-\\ тация\end{tabular}              & Средняя                                                        & Средняя                                                             & Средняя                                                        & Малая                                                          & Малая                                                          & Большая                                                                  \\ \hline
			\begin{tabular}[c]{@{}c@{}}Требования\\ к ядру\end{tabular}           & \begin{tabular}[c]{@{}c@{}}Версия \\ старше\\ 2.6\end{tabular} & Нет                                                                 & \begin{tabular}[c]{@{}c@{}}Версия \\ старше\\ 2.0\end{tabular} & -                                                              & Нет                                                            & \begin{tabular}[c]{@{}c@{}}Наличие\\ ftrace\end{tabular}                 \\ \hline
			\end{tabular}
		\label{table:compare:hooking}
	\end{table}

	Анализируя данную таблицу можно сделать вывод, 
	что для решения поставленной задачи наиболее 
	подходящими являются методы модификации таблицы 
	системных функций и ftrace, т.к. они не требуют
	перекомпиляции ядра и поддерживаются большинством версий ядер,
	а также не вызывают большой технической сложности в реализации.

\section{Выводы}
	В результате анализа работы операционной системы Linux
	с файловыми системами были определены необходимые для мониторинга функции, 
	которые позволят исследовать особенности работы ядра с файлами.

	В результате сравнительного анализа методов перехвата было выбрано два метода.
	Первый метод -- метод модификации таблицы системных вызовов sys\_call\_table
	позволит перехватывать вызовы системных функции sys\_read, sys\_write, sys\_open и sys\_close 
	без больших накладных расходов. 
	Второй -- используя библиотеку ftrace, 
	которая позволит перехватывать функции bdev\_read\_page, bdev\_write\_page и random\_read, 
	т.к. они не определены в таблице sys\_call\_table.

	Выбранные методы перехвата требуют, 
	чтобы сигнатуры перехватываемой функций и функции-перехватчика должны в точности совпадать.
	Иначе, очевидно, аргументы будут переданы неправильно и дальнейшее поведение ядра не определено.
	Из-за этого возникают сложности с поддержкой разных версий ядер Линукса,
	т.к. разработчики ядра не поддерживают обратную совместимость.
	В рамках курсовой работы будет реализована поддержка лишь одной версии ядра -- 5.0.

	% В ходе анализа приведенных подходов к перехвату функций,
	% были выбраны метод модификации таблицы системных вызовов sys\_call\_table и фреймворк ftrace, 
	% так как первый позволит перехватить вызов системных функции sys\_read, sys\_write, sys\_open и sys\_close 
	% без больших накладных расходов.
	% Второй же метод будет 
	% Основными критериями выбора были необходимость перекомпилировать ядро,
	% требования к ядру, а также сложность программной реализации.

	

% \section{Загружаемые модули ядра Linux}
% 	Linux является динамическим ядром, 
% 	поддерживающим добавление и удаление программных компонентов на лету \cite{anatomy-linux-kernel}.
% 	Это означает, есть возможность добавить функциональность в ядро (и убрать её), когда система запущена и работает.
% 	Они называются динамически загружаемыми модулями ядра.
% 	Ядро Linux предлагает поддержку довольно большого числа типов (или классов) модулей.
% 	Каждый модуль является подготовленным объектным кодом (не слинкованным для самостоятельной работы),
% 	который может быть динамически подключен в работающее ядро, а позднее может быть выгружен из ядра.
% 	Каждый модуль ядра регистрирует себя для того, чтобы обслуживать в будущем запросы,
% 	и его функция инициализации немедленно прекращается. 
% 	Иными словами, задача функции инициализации модуля заключается в подготовке функций модуля для последующего вызова.
% 	Функция выхода модуля вызывается только непосредственно перед выгрузкой модуля. 
% 	Функция выхода модуля должна тщательно отменить все изменения, сделанные функцией инициализации, 
% 	или функции модуля сохранятся до перезагрузки системы. 
% 	Возможность выгрузить модуль помогает сократить время разработки; 
% 	можно тестировать последовательные версии новых драйверов, 
% 	не прибегая каждый раз к длительному циклу выключения/перезагрузки. 
% 	Модуль связан только с ядром и может вызывать только те функции, 
% 	которые экспортированы ядром, нет библиотек для установления связи. 
% 	Например, функция printk, является версией printf, 
% 	определённой в ядре и экспортированной для модулей.
	
% 	В основном загружаемые модули ядра используются в следующих целях:
% 	\begin{enumerate}
% 		\item драйверы устройств;
% 		\item драйверы файловой системы;
% 		\item добавление новых системных вызовов и расширение функционала существующих.
% 	\end{enumerate}

% \section{Пространство пользователя и пространство ядра}
% 	Систему памяти в Linux можно разделить на две различные области: пространства ядра и пользовательского пространства.
% 	Пространство ядра -- адресное пространство в абсолютных адресах,
% 	где выполняется ядро операционной системы и предоставляет свои услуги \cite{linux-kernel-space}.
% 	Пользовательское пространство (user space) -- адресное пространство виртуальной памяти операционной системы,
% 	в которой выполняются процессы пользователя \cite{linux-user-space}.
	
% 	Доступ к пространству ядра для пользовательских процессов возможен только с помощью системных вызовов.
% 	Системные вызовы -- это запросы в Unix-подобной операционной системе активного процесса для службы,
% 	выполняемой ядром, такой как ввод/вывод (I/O) или создание процесса и т.д.

% \section{Вывод}
% 	В данном разделе были проанализированы подходы к трассировке ядра и перехвату функций и 
% 	выбраны наиболее оптимальные методы для реализации поставленных задач -- модификации таблицы
% 	системных вызовов и фреймворк ftrace, 
% 	а также рассмотрены основные принципы загружаемых модулей ядра и понятия пространства ядра и пространства пользователя.
	
\pagebreak